---
// FixedSection.astro - Reusable sticky section component
export interface Props {
  id: string
  title: string
  className?: string
  contentClassName?: string
}

const { id, title, className = '', contentClassName = '' } = Astro.props
---

<section id={id} class={`relative ${className}`}>
  <!-- Sticky Sub-header -->
  <div class={`sticky-subheader  sticky top-20 z-40`} data-section={id}>
    <div class="mx-auto">
      <div class="text-base font-bold text-white">{title}</div>
    </div>
  </div>

  <!-- Content -->
  <div class={`content-area min-full-screen  ${contentClassName}`}>
    <div class="r mx-auto px-4 py-16">
      <div class="mx-auto max-w-3xl">
        <slot />
      </div>
    </div>
  </div>
</section>
<!-- <script>
    // TypeScript for sticky subheader behavior
    interface StickySubheader {
      element: HTMLElement;
      contentArea: HTMLElement;
      sectionId: string;
    }

    function initStickySubheaders(): void {
      const stickySubheaders: StickySubheader[] = Array.from(
        document.querySelectorAll('.sticky-subheader')
      ).map((element) => {
        const htmlElement = element as HTMLElement;
        const sectionId = htmlElement.dataset.section || '';
        const contentArea = htmlElement.nextElementSibling as HTMLElement;
        
        return {
          element: htmlElement,
          contentArea,
          sectionId
        };
      });

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            const target = entry.target as HTMLElement;
            const subheader = stickySubheaders.find(
              (sh) => sh.contentArea === target
            );
            
            if (subheader) {
              const rect = entry.boundingClientRect;
              const isAboveViewport = rect.bottom < 80; // Header height
              const isInViewport = entry.isIntersecting;
              
              if (isAboveViewport) {
                // Content has scrolled completely past - unstick the header
                subheader.element.style.position = 'static';
                subheader.element.style.opacity = '0.5';
              } else if (isInViewport || rect.top <= 80) {
                // Content is visible or header should stick
                subheader.element.style.position = 'sticky';
                subheader.element.style.opacity = '1';
              } else {
                // Content is below viewport - header should be hidden/static
                subheader.element.style.position = 'static';
                subheader.element.style.opacity = '0.8';
              }
            }
          });
        },
        {
          rootMargin: '-80px 0px -50% 0px', // Account for header and trigger earlier
          threshold: [0, 0.1, 0.5, 1]
        }
      );

      // Observe all content areas
      stickySubheaders.forEach((subheader) => {
        observer.observe(subheader.contentArea);
      });

      // Additional scroll handler for more reliable sticky behavior
      let ticking = false;
      
      function updateStickyHeaders() {
        const scrollTop = window.pageYOffset;
        const headerHeight = 80;
        
        stickySubheaders.forEach((subheader) => {
          const sectionRect = subheader.contentArea.getBoundingClientRect();
          const sectionTop = sectionRect.top + scrollTop;
          const sectionBottom = sectionRect.bottom + scrollTop;
          
          if (scrollTop >= sectionTop - headerHeight && scrollTop < sectionBottom - headerHeight) {
            // Section is active, header should be sticky
            subheader.element.style.position = 'sticky';
            subheader.element.style.opacity = '1';
          } else if (scrollTop >= sectionBottom - headerHeight) {
            // Section has scrolled past, header should unstick
            subheader.element.style.position = 'static';
            subheader.element.style.opacity = '0.5';
          } else {
            // Section is below viewport, header should be static
            subheader.element.style.position = 'static';
            subheader.element.style.opacity = '0.8';
          }
        });
        
        ticking = false;
      }
      
      function onScroll() {
        if (!ticking) {
          requestAnimationFrame(updateStickyHeaders);
          ticking = true;
        }
      }
      
      window.addEventListener('scroll', onScroll);
      
      // Initial call
      updateStickyHeaders();
    }

    // Initialize when DOM is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initStickySubheaders);
    } else {
      initStickySubheaders();
    }

    // Smooth scrolling for navigation links
    document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
      anchor.addEventListener('click', (e: Event) => {
        e.preventDefault();
        const href = (e.currentTarget as HTMLAnchorElement).getAttribute('href');
        if (href) {
          const target = document.querySelector(href);
          if (target) {
            const offsetTop = (target as HTMLElement).offsetTop - 80; // Account for header
            window.scrollTo({
              top: offsetTop,
              behavior: 'smooth'
            });
          }
        }
      });
    });
  </script> -->

<!-- 
---
/**
 * FixedHeader Component
 * 
 * A reusable Astro component that creates a fixed header section at the top of the page.
 * The header remains visible while scrolling and includes automatic ID generation for
 * accessibility and styling purposes.
 * 
 * @component
 */

/**
 * Component props interface
 * @interface Props
 * @property {string} [class] - Optional Tailwind CSS classes to customize the header appearance
 * @property {string} [id] - Optional custom ID for the section element. If not provided, 
 *                           a random ID in format 'section-[randomString]' will be generated
 */
interface Props {
  class?: string;
  id?: string;
  headerText?: string;
}

const { class: className, id, headerText } = Astro.props;

/**
 * Generate a unique random ID if none is provided
 * Format: 'section-' followed by a 9-character alphanumeric string
 * @type {string}
 */
const sectionId = id || `section-${Math.random().toString(36).substr(2, 9)}`;
---

<section id={sectionId} class={`fixed-section ${className || ''}`}>
    <div class="fixed-section__header">{headerText}</div>
    <div class="fixed-section__content">
        <slot />
    </div>

</section> -->
